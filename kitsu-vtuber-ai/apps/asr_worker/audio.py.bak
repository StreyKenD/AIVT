from __future__ import annotations

import asyncio
import contextlib
from typing import AsyncIterator, Callable, Optional, Protocol, cast

from .config import ASRConfig
from .logger import logger
from .utils import load_module_if_available


class AudioSource(Protocol):
    def frames(self) -> AsyncIterator[bytes]:
        """Yield PCM16 audio frames of a fixed duration."""


class ManagedAudioSource(AudioSource, Protocol):
    async def start(self) -> None:
        ...

    async def stop(self) -> None:
        ...


class SoundDeviceStream(Protocol):
    def start(self) -> None:
        ...

    def stop(self) -> None:
        ...

    def close(self) -> None:
        ...


class SoundDeviceModule(Protocol):
    def RawInputStream(self, *args: object, **kwargs: object) -> SoundDeviceStream:
        ...


class PyAudioStream(Protocol):
    def read(self, frames: int) -> bytes:
        ...

    def stop_stream(self) -> None:
        ...

    def close(self) -> None:
        ...


class PyAudioInterface(Protocol):
    def open(self, *args: object, **kwargs: object) -> PyAudioStream:
        ...

    def terminate(self) -> None:
        ...


class PyAudioModule(Protocol):
    paInt16: object

    def PyAudio(self) -> PyAudioInterface:
        ...


class FakeAudioSource:
    """Generates silence for smoke tests or when no device is available."""

    def __init__(self, frame_bytes: int, interval: float) -> None:
        self._frame_bytes = frame_bytes
        self._interval = interval
        self._running = True

    def frames(self) -> AsyncIterator[bytes]:
        blank = b"\x00" * self._frame_bytes

        async def _generator() -> AsyncIterator[bytes]:
            while self._running:
                await asyncio.sleep(self._interval)
                yield blank

        return _generator()

    def stop(self) -> None:
        self._running = False


class SoundDeviceAudioSource:
    def __init__(self, config: ASRConfig) -> None:
        self._config = config
        module = load_module_if_available("sounddevice")
        if module is None:
            raise RuntimeError("sounddevice is not installed")
        self._module = cast(SoundDeviceModule, module)
        self._queue: asyncio.Queue[bytes] = asyncio.Queue(maxsize=32)
        self._stream: SoundDeviceStream | None = None
        self._loop: Optional[asyncio.AbstractEventLoop] = None

    async def start(self) -> None:
        self._loop = asyncio.get_running_loop()
        self._stream = self._module.RawInputStream(
            samplerate=self._config.sample_rate,
            blocksize=self._config.frame_samples,
            channels=1,
            dtype="int16",
            device=self._config.input_device,
            callback=self._on_frame,
        )
        self._stream.start()

    async def stop(self) -> None:
        if self._stream is not None:
            self._stream.stop()
            self._stream.close()
            self._stream = None

    def _on_frame(self, indata, frames, _time, status) -> None:  # pragma: no cover
        if status:
            logger.debug("sounddevice status: %s", status)
        data = bytes(indata)
        if self._loop is None:
            return
        self._loop.call_soon_threadsafe(self._enqueue, data)

    def _enqueue(self, data: bytes) -> None:
        try:
            self._queue.put_nowait(data)
        except asyncio.QueueFull:
            with contextlib.suppress(asyncio.QueueEmpty):
                self._queue.get_nowait()
            try:
                self._queue.put_nowait(data)
            except asyncio.QueueFull:
                logger.debug("Dropped audio frame due to full queue")

    def frames(self) -> AsyncIterator[bytes]:
        async def _generator() -> AsyncIterator[bytes]:
            while True:
                frame = await self._queue.get()
                yield frame

        return _generator()


class PyAudioSource:
    def __init__(self, config: ASRConfig) -> None:
        self._config = config
        module = load_module_if_available("pyaudio")
        if module is None:
            raise RuntimeError("pyaudio is not installed")
        self._module = cast(PyAudioModule, module)
        self._queue: asyncio.Queue[bytes] = asyncio.Queue(maxsize=32)
        self._stream: PyAudioStream | None = None
        self._pa: PyAudioInterface | None = None
        self._loop: Optional[asyncio.AbstractEventLoop] = None
        self._worker: Optional[asyncio.Task[None]] = None

    async def start(self) -> None:
        self._loop = asyncio.get_running_loop()
        self._pa = self._module.PyAudio()
        self._stream = self._pa.open(
            format=self._module.paInt16,
            channels=1,
            rate=self._config.sample_rate,
            input=True,
            frames_per_buffer=self._config.frame_samples,
            input_device_index=self._config.input_device,
        )
        self._worker = asyncio.create_task(self._reader())

    async def stop(self) -> None:
        if self._worker is not None:
            self._worker.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await self._worker
            self._worker = None
        if self._stream is not None:
            self._stream.stop_stream()
            self._stream.close()
            self._stream = None
        if self._pa is not None:
            self._pa.terminate()
            self._pa = None

    async def _reader(self) -> None:  # pragma: no cover - hardware guard
        assert self._stream is not None
        while True:
            data = await asyncio.get_running_loop().run_in_executor(
                None,
                self._stream.read,
                self._config.frame_samples,
            )
            try:
                self._queue.put_nowait(data)
            except asyncio.QueueFull:
                try:
                    self._queue.get_nowait()
                except asyncio.QueueEmpty:
                    pass
                try:
                    self._queue.put_nowait(data)
                except asyncio.QueueFull:
                    logger.debug("Dropped PyAudio frame due to full queue")

    def frames(self) -> AsyncIterator[bytes]:
        async def _generator() -> AsyncIterator[bytes]:
            while True:
                frame = await self._queue.get()
                yield frame

        return _generator()


@contextlib.asynccontextmanager
async def acquire_audio_source(config: ASRConfig) -> AsyncIterator[AudioSource]:
    frame_interval = config.frame_duration_ms / 1000
    if config.fake_audio:
        logger.warning("ASR worker using synthetic audio source (silence mode)")
        source = FakeAudioSource(config.frame_bytes, frame_interval)
        try:
            yield source
        finally:
            source.stop()
        return

    factories: list[tuple[str, Callable[[ASRConfig], ManagedAudioSource]]] = [
        ("sounddevice", SoundDeviceAudioSource),
        ("pyaudio", PyAudioSource),
    ]

    for name, factory in factories:
        try:
            backend = factory(config)
        except RuntimeError as exc:
            logger.debug("Audio backend %s unavailable: %s", name, exc)
            continue
        try:
            await backend.start()
            logger.info("ASR worker capturing audio with %s", name)

            try:
                yield backend
            finally:
                await backend.stop()
            return
        except Exception as exc:  # pragma: no cover - device guard
            logger.warning(
                "Failed to start audio capture with %s: %s", name, exc, exc_info=True
            )
            with contextlib.suppress(Exception):
                await backend.stop()

    logger.warning("No audio backend available; using synthetic mode")
    fallback = FakeAudioSource(config.frame_bytes, frame_interval)
    try:
        yield fallback
    finally:
        fallback.stop()


__all__ = [
    "AudioSource",
    "FakeAudioSource",
    "ManagedAudioSource",
    "PyAudioSource",
    "SoundDeviceAudioSource",
    "acquire_audio_source",
]

