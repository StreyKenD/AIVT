<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Kitsu Chat Console</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg-main: #10131a;
      --bg-panel: #18202c;
      --bg-input: #1f2937;
      --text-primary: #f5f7fa;
      --text-secondary: #a3acc2;
      --accent: #ff7ac3;
      --accent-soft: rgba(255, 122, 195, 0.12);
      --user-bg: rgba(76, 151, 255, 0.12);
      --assistant-bg: rgba(255, 122, 195, 0.14);
      --border: rgba(255, 255, 255, 0.08);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      font-family: "Segoe UI", Tahoma, Arial, sans-serif;
      background-color: var(--bg-main);
      color: var(--text-primary);
    }

    header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(135deg, rgba(31, 41, 55, 0.9), rgba(18, 22, 31, 0.95));
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 1rem;
    }

    header h1 {
      margin: 0;
      font-size: 1.1rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    #status-bar {
      font-size: 0.85rem;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    #connection-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    #connection-light {
      width: 0.55rem;
      height: 0.55rem;
      border-radius: 50%;
      background-color: #ff5c5c;
      box-shadow: 0 0 8px rgba(255, 92, 92, 0.6);
      transition: background-color 0.2s ease, box-shadow 0.2s ease;
    }

    #connection-indicator.connected #connection-light {
      background-color: #5cff9d;
      box-shadow: 0 0 10px rgba(92, 255, 157, 0.8);
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      padding: 1.25rem;
    }

    #conversation {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      background: var(--bg-panel);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .message {
      padding: 0.9rem 1.1rem;
      border-radius: 0.75rem;
      max-width: 72ch;
      line-height: 1.45;
      white-space: pre-wrap;
      word-break: break-word;
      border: 1px solid transparent;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
    }

    .message.user {
      align-self: flex-end;
      background: var(--user-bg);
      border-color: rgba(76, 151, 255, 0.25);
    }

    .message.assistant {
      align-self: flex-start;
      background: var(--assistant-bg);
      border-color: rgba(255, 122, 195, 0.22);
    }

    .message.pending {
      font-style: italic;
      opacity: 0.8;
    }

    .message .meta {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-bottom: 0.35rem;
      color: var(--text-secondary);
    }

    form {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      padding: 1rem;
      background: var(--bg-panel);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
    }

    #chat-input {
      width: 100%;
      min-height: 3.2rem;
      resize: vertical;
      border-radius: 0.65rem;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: var(--bg-input);
      color: var(--text-primary);
      padding: 0.75rem 1rem;
      font-size: 1rem;
      line-height: 1.4;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    #chat-input:focus {
      outline: none;
      border-color: rgba(255, 122, 195, 0.55);
      box-shadow: 0 0 0 2px rgba(255, 122, 195, 0.2);
    }

    #controls {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    #send-button {
      background: var(--accent);
      border: none;
      color: #0f0f14;
      font-weight: 600;
      padding: 0.65rem 1.4rem;
      border-radius: 999px;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
      box-shadow: 0 10px 22px rgba(255, 122, 195, 0.3);
    }

    #send-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
    }

    #send-button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 14px 26px rgba(255, 122, 195, 0.35);
    }

    #options {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    #alert {
      display: none;
      padding: 0.75rem 1rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(255, 103, 128, 0.5);
      background: rgba(255, 103, 128, 0.15);
      color: #ffd5dd;
      font-size: 0.9rem;
    }

    #persona-tag {
      border: 1px solid var(--border);
      padding: 0.2rem 0.5rem;
      border-radius: 999px;
      font-size: 0.75rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-secondary);
    }

    a {
      color: var(--accent);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    @media (max-width: 700px) {
      header {
        flex-direction: column;
        align-items: flex-start;
      }

      main {
        padding: 1rem;
      }

      form {
        padding: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Kitsu.exe Chat Console</h1>
    <div id="status-bar">
      <span id="persona-tag">Persona loading...</span>
      <span id="connection-indicator">
        <span id="connection-light"></span>
        <span id="connection-label">Connecting</span>
      </span>
    </div>
  </header>

  <main>
    <div id="conversation" aria-live="polite"></div>

    <div id="alert" role="alert"></div>

    <form id="chat-form" autocomplete="off">
      <textarea
        id="chat-input"
        name="message"
        placeholder="Type a message for Kitsu..."
        required
      ></textarea>
      <div id="controls">
        <div id="options">
          <label for="play-tts">
            <input type="checkbox" id="play-tts" name="play_tts" checked>
            Request TTS response
          </label>
        </div>
        <button type="submit" id="send-button">Send</button>
      </div>
    </form>
  </main>

  <script>
    (function () {
      const conversationEl = document.getElementById("conversation");
      const form = document.getElementById("chat-form");
      const input = document.getElementById("chat-input");
      const sendButton = document.getElementById("send-button");
      const playTTS = document.getElementById("play-tts");
      const alertBox = document.getElementById("alert");
      const personaTag = document.getElementById("persona-tag");
      const indicator = document.getElementById("connection-indicator");
      const indicatorLabel = document.getElementById("connection-label");

      const messages = [];
      const pendingMap = new Map();
      let activeRequestId = null;
      let websocket = null;
      let reconnectHandle = null;

      function setAlert(message) {
        if (!message) {
          alertBox.style.display = "none";
          alertBox.textContent = "";
          return;
        }
        alertBox.style.display = "block";
        alertBox.textContent = message;
      }

      function updateConnectionStatus(state) {
        if (state === "connected") {
          indicator.classList.add("connected");
          indicatorLabel.textContent = "Connected";
        } else if (state === "connecting") {
          indicator.classList.remove("connected");
          indicatorLabel.textContent = "Connecting";
        } else {
          indicator.classList.remove("connected");
          indicatorLabel.textContent = "Disconnected";
        }
      }

      function decodeEntities(value) {
        const textarea = document.createElement("textarea");
        textarea.innerHTML = value;
        return textarea.value;
      }

      function extractSpeech(content) {
        if (!content) {
          return "";
        }
        const match = content.match(/<speech>([\s\S]*?)<\/speech>/i);
        if (match) {
          return decodeEntities(match[1].trim());
        }
        const stripped = content.replace(/<[^>]+>/g, " ").replace(/\s+/g, " ").trim();
        return decodeEntities(stripped);
      }

      function render() {
        conversationEl.innerHTML = "";
        messages.forEach((msg) => {
          const wrapper = document.createElement("div");
          wrapper.className = "message " + msg.role;

          const meta = document.createElement("div");
          meta.className = "meta";
          meta.textContent = msg.role === "assistant" ? "Kitsu" : "You";
          wrapper.appendChild(meta);

          const text = document.createElement("div");
          text.className = "text";
          text.textContent = msg.text;
          wrapper.appendChild(text);

          conversationEl.appendChild(wrapper);
        });

        const pendingText = getPendingText();
        if (pendingText) {
          const wrapper = document.createElement("div");
          wrapper.className = "message assistant pending";
          const meta = document.createElement("div");
          meta.className = "meta";
          meta.textContent = "Kitsu is thinking...";
          wrapper.appendChild(meta);
          const text = document.createElement("div");
          text.className = "text";
          text.textContent = pendingText;
          wrapper.appendChild(text);
          conversationEl.appendChild(wrapper);
        }

        conversationEl.scrollTop = conversationEl.scrollHeight;
      }

      function getPendingText() {
        if (activeRequestId && pendingMap.has(activeRequestId)) {
          return pendingMap.get(activeRequestId);
        }
        const entries = Array.from(pendingMap.values());
        return entries.length ? entries[entries.length - 1] : "";
      }

      function addMessage(role, text) {
        messages.push({ role, text, ts: Date.now() });
        render();
      }

      function handleToken(payload) {
        const id = payload.request_id || "default";
        const token = payload.token || payload.text || "";
        if (!pendingMap.has(id)) {
          pendingMap.set(id, "");
        }
        pendingMap.set(id, pendingMap.get(id) + token);
        activeRequestId = id;
        render();
      }

      function handleFinal(payload) {
        const id = payload.request_id || activeRequestId || "default";
        const content = payload.content || "";
        const speech = extractSpeech(content);
        const finalText = speech || extractSpeech(payload.meta?.fallback_text || "");
        if (finalText) {
          addMessage("assistant", finalText);
        }
        pendingMap.delete(id);
        if (activeRequestId === id) {
          activeRequestId = null;
        }
        render();
      }

      function scheduleReconnect() {
        if (reconnectHandle !== null) {
          return;
        }
        reconnectHandle = setTimeout(() => {
          reconnectHandle = null;
          connect();
        }, 2000);
      }

      function connect() {
        if (websocket && websocket.readyState === WebSocket.OPEN) {
          return;
        }
        updateConnectionStatus("connecting");
        const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        websocket = new WebSocket(protocol + "//" + window.location.host + "/stream");

        websocket.addEventListener("open", () => {
          updateConnectionStatus("connected");
          setAlert("");
        });

        websocket.addEventListener("close", () => {
          updateConnectionStatus("disconnected");
          scheduleReconnect();
        });

        websocket.addEventListener("error", (event) => {
          console.error("WebSocket error", event);
          updateConnectionStatus("disconnected");
          scheduleReconnect();
        });

        websocket.addEventListener("message", (event) => {
          try {
            const message = JSON.parse(event.data);
            switch (message.type) {
              case "status": {
                const persona = message.payload?.persona?.style;
                if (persona) {
                  personaTag.textContent = "Persona: " + persona;
                }
                break;
              }
              case "policy.token":
                handleToken(message.payload || {});
                break;
              case "policy.final":
                handleFinal(message.payload || {});
                break;
            }
          } catch (err) {
            console.error("Failed to parse message", err);
          }
        });
      }

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        const text = input.value.trim();
        if (!text) {
          return;
        }
        setAlert("");
        addMessage("user", text);
        input.value = "";
        sendButton.disabled = true;

        try {
          const response = await fetch("/chat/respond", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text, play_tts: playTTS.checked }),
          });
          if (!response.ok) {
            const detail = await response.json().catch(() => ({}));
            throw new Error(detail?.detail || "Request failed");
          }
          await response.json();
        } catch (error) {
          console.error(error);
          setAlert(String(error.message || error));
        } finally {
          sendButton.disabled = false;
          input.focus();
        }
      });

      connect();
      render();
    })();
  </script>
</body>
</html>
